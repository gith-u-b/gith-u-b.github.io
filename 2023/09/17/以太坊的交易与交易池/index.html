<!DOCTYPE html>
<html lang="zh-CN">


<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>
    以太坊的交易与交易池 | Step by Step
  </title>
  <meta name="description" content="一步一步的">
  
  <meta name="keywords" content="
  web3
  ">
  
  <meta name="author" content="Sai">

  <meta http-equiv="Cache-Control" content="no-transform"/>
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="theme-color" content="#1e2327">
  <link rel="apple-touch-icon" href="https://github.githubassets.com/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://github.githubassets.com/apple-touch-icon-180x180.png">

  <link rel="icon" type="image/x-icon" href="https://www.sai.show/favicon.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet"
        href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  

  

  <script src="//cdnjs.cloudflare.com/ajax/libs/vue/1.0.25-csp/vue.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.11.2/moment.min.js"></script>
<meta name="generator" content="Hexo 6.3.0"></head>

<body id="replica-app">

<nav class="navbar-wrapper">
  <div class="navbar">
    <div class="container clearfix">
      <a href="/" class="navbar-logo"><i class="fa fa-github"></i></a>

      <div class="navbar-search float-left desktop-only">
        <div class="navbar-search-form">
          <label for="gsc-i-id1">This website</label>
          <div id="google-search">
            <gcse:search></gcse:search>
          </div>
        </div>
      </div>

      <ul class="navbar-nav float-left">
        
        <li><a href="/archives">Archives</a></li>
        
        
        <li><a href="/categories">Categories</a></li>
        
        
        <li><a href="/tags">Tags</a></li>
        
        
        
          <li class="desktop-only"><a href="/about" >About</a></li>
          
        
        <li class="desktop-only"><a href="/atom.xml" target="_blank">RSS</a></li>
        
      </ul>

      <ul class="navbar-nav user-nav float-right desktop-only">
        <li class="user-nav-notification">
          <a><span class="user-nav-unread"></span><i class="fa fa-bell"></i></a>
        </li>
        <li>
          <a><i class="fa fa-plus"></i> <i class="fa fa-caret-down"></i></a>
        </li>
        <li class="user-nav-logo">
          <a><img src="https://avatars.githubusercontent.com/u/56356960?s=400"> <i class="fa fa-caret-down"></i></i></a>
        </li>
      </ul>
    </div>
  </div>
</nav>

<div class="main-container">
  <header class="header-wrapper desktop-only">
  <div class="container header-site-detail">
    <ul class="header-toolbar">
      <li class="clearfix">
        <a href="/archives" class="header-toolbar-left"><i
                  class="fa fa-file-text"></i> Posts </a>
        <a href="/archives"
           class="header-toolbar-right"> 14 </a>
      </li>
      <li>
        <a href="/tags" class="header-toolbar-left"><i
                  class="fa fa-tags"></i> Tags </a>
        <a href="/tags"
           class="header-toolbar-right"> 7 </a>
      </li>
      <li>
        <a href="/categories" class="header-toolbar-left"><i
                  class="fa fa-folder-open"></i> Categories </a>
        <a href="/categories"
           class="header-toolbar-right"> 7 </a>
      </li>
    </ul>
    <h2 class="header-title">
      <i class="fa fa-book text-muted"></i>
      <a href="/">Step by Step</a>
      
      
    </h2>
  </div>

  <div class="container">
    <div class="header-tab-wrapper clearfix">
      <span class="header-tab header-tab-selected"><i class="fa fa-thumbs-o-up"></i> Like</span>
      <span class="header-tab"><i class="fa fa-share-alt"></i> Share</span>
      <span class="header-tab"><i class="fa fa-comments-o"></i> Discussion</span>
      <span class="header-tab"><i class="fa fa-bookmark-o"></i> Bookmark </span>
      <span class="header-tab"><i class="fa fa-smile-o"></i> Smile <i class="fa fa-caret-down"></i></span>
    </div>
  </div>
</header>


<div class="post-container container">
  <h3>
    <i class="fa fa-user-o"></i>
    Sai

    <span class="post-date float-right" title="{{moment(1694884822000).format('MMM DD, YYYY, h:mm:ss A')}}">
      
          <i class="fa fa-pencil-square-o"></i>
      
      {{moment(1694884822000).fromNow()}}
    </span>
  </h3>

  <article class="post-content">
    <h1>以太坊的交易与交易池</h1>
    <h2 id="概述"><a class="markdownIt-Anchor" href="#概述">#</a> 概述</h2>
<p>本篇文章将在此基础上介绍以下内容:</p>
<ul>
<li>客户端如何构建一笔交易</li>
<li>服务端如何处理交易并进行打包</li>
</ul>
<p>本文以一笔交易的生命周期为主线安排全文，从交易池初始化、交易构造到交易执行，尽可能为读者全景展示以太坊中的交易所涉及的方方面面。</p>
<p><img src="https://img.gejiba.com/images/3cf30c9764d5209801178e963e1f5ff7.png" alt=""></p>
<h2 id="交易池初始化"><a class="markdownIt-Anchor" href="#交易池初始化">#</a> 交易池初始化</h2>
<p>在交易进行之前，节点首先需要完成节点初始化，本节内容主要聚焦于此。</p>
<p>节点需要对以下数据进行初始化:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">type TxPoolConfig struct &#123;</span><br><span class="line">	Locals    []common.Address // Addresses that should be treated by default as local</span><br><span class="line">	NoLocals  bool             // Whether local transaction handling should be disabled</span><br><span class="line">	Journal   string           // Journal of local transactions to survive node restarts</span><br><span class="line">	Rejournal time.Duration    // Time interval to regenerate the local transaction journal</span><br><span class="line"></span><br><span class="line">	PriceLimit uint64 // Minimum gas price to enforce for acceptance into the pool</span><br><span class="line">	PriceBump  uint64 // Minimum price bump percentage to replace an already existing transaction (nonce)</span><br><span class="line"></span><br><span class="line">	AccountSlots uint64 // Number of executable transaction slots guaranteed per account</span><br><span class="line">	GlobalSlots  uint64 // Maximum number of executable transaction slots for all accounts</span><br><span class="line">	AccountQueue uint64 // Maximum number of non-executable transaction slots permitted per account</span><br><span class="line">	GlobalQueue  uint64 // Maximum number of non-executable transaction slots for all accounts</span><br><span class="line"></span><br><span class="line">	Lifetime time.Duration // Maximum amount of time non-executable transaction are queued</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>各参数含义如下:</p>
<ul>
<li><code>Locals</code>  本地账户地址列表。在以太坊执行层节点内，本地交易拥有一系列特权，节点会监控交易来源地址并确定是否将其列为本地交易</li>
<li><code>NoLocals</code>  禁止本地交易处理，将所有交易均列为远程交易 (即无特权交易)</li>
<li><code>Journal</code>  对交易池内的本地交易进行数据持久化的文件名</li>
<li><code>Rejournal</code>  进行数据持久化的时间间隔</li>
<li><code>PriceLimit</code>  交易池接受到最小 gas 价格，在 EIP1559 交易中代表最小 Priority Fee 价格</li>
<li><code>PriceBump</code>  交易 gas 价格提升的最小百分比</li>
<li><code>AccountSlots</code>  单个账户可执行交易的最大容量</li>
<li><code>GlobalSlots</code>  所有账户可执行交易的最大容量</li>
<li><code>AccountQueue</code>  最大单个账户非可执行交易容量</li>
<li><code>GlobalQueue</code>  全局最大非可执行交易容量</li>
<li><code>Lifetime</code>  非可执行交易的存活时间</li>
</ul>
<p>我们在上文中使用了交易容量而非交易数量，两者具有一定的区别，一般来说，一笔交易占用 1 单位交易容量，具体计算公式如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func numSlots(tx *types.Transaction) int &#123;</span><br><span class="line">	return int((tx.Size() + txSlotSize - 1) / txSlotSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>txSlotSize</code>  为常量，其值为 <code>32768</code> 。 <code>tx.Size()</code>  代表一笔交易经过 <code>RLP</code>  编码后的体积，单位为 <code>bytes</code> 。正常交易都仅占用 1 单位交易容量。</p>
<blockquote>
<p>设置上述规则的原因在于避免部分用户构建超大交易占用交易池资源，正常来说一笔交易仅占用 <code>2000 bytes</code>  左右。</p>
</blockquote>
<p>上述各值的初始化如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var DefaultTxPoolConfig = TxPoolConfig&#123;</span><br><span class="line">	Journal:   &quot;transactions.rlp&quot;,</span><br><span class="line">	Rejournal: time.Hour,</span><br><span class="line"></span><br><span class="line">	PriceLimit: 1,</span><br><span class="line">	PriceBump:  10,</span><br><span class="line"></span><br><span class="line">	AccountSlots: 16,</span><br><span class="line">	GlobalSlots:  4096 + 1024, // urgent + floating queue capacity with 4:1 ratio</span><br><span class="line">	AccountQueue: 64,</span><br><span class="line">	GlobalQueue:  1024,</span><br><span class="line"></span><br><span class="line">	Lifetime: 3 * time.Hour,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在交易池中，我们把交易分为远程交易 ( <code>remote transactions</code> ) 和本地交易 ( <code>local transaction</code> )。其中，后者具有以下优先级:</p>
<ol>
<li>写入 Journal 文件中，在节点启动时直接载入交易池</li>
<li>不受交易池中的 PriceLimit 等限制</li>
<li>在交易排序时优先级最高</li>
<li>不会因为交易队列已满等原因被交易队列剔除</li>
</ol>
<p>我们使用 <code>RPC API</code>  向节点发送的交易也属于 <code>local transactions</code>  (前提为节点将 <code>NoLocals</code>  设置为 <code>False</code> )。</p>
<blockquote>
<p>此处的 <code>PriceLimit</code>  参数对应 <code>EIP1559</code>  交易中的<a target="_blank" rel="noopener" href="https://www.sai.show/2023/09/10/%E7%90%86%E8%A7%A3%E4%BB%A5%E5%A4%AA%E5%9D%8AGas-%E7%87%83%E6%96%99%E5%92%8C%E4%BA%A4%E6%98%93%E6%89%8B%E7%BB%AD%E8%B4%B9/#max-fee"> Max Fee</a> 参数，这意味着只要 <code>Max Fee</code>  大于 <code>PriceLimit</code>  即可进入交易池</p>
</blockquote>
<p>在此处也出现了两种交易类型，如下:</p>
<ol>
<li>可执行交易 (executable transaction)，此交易位于 <code>pending</code>  队列中，极有可能被节点封装进入下一个区块</li>
<li>不可执行交易 (non-executable transaction)，此交易位于 <code>queued</code>  队列中，不太可能被节点封装进入下一个区块</li>
</ol>
<blockquote>
<p>封装 ( <code>seal</code> ) 是目前以太坊对于区块打包的描述</p>
</blockquote>
<p>我们通过<a target="_blank" rel="noopener" href="https://github.com/ethereum/go-ethereum/blob/052c634/core/tx_pool.go#L279"> NewTxPool</a> 函数使用上述初始化配置实现交易池的初始化。</p>
<p>初始化完成后，我们通过<a target="_blank" rel="noopener" href="https://github.com/ethereum/go-ethereum/blob/052c634/core/tx_pool.go#L430"> SubscribeNewTxsEvent</a> 函数订阅在以太坊网络中广播的新的交易项目。</p>
<h2 id="交易构造"><a class="markdownIt-Anchor" href="#交易构造">#</a> 交易构造</h2>
<p>本节内容主要介绍客户端如何构造一笔以太坊交易。鉴于本文的很多读者并没有独立运行的以太坊节点，我们在此处主要介绍通过以太坊的 API 构建交易。</p>
<p>在一笔交易的最初阶段，用户需要完成交易的初始化，设置一笔交易的各个参数。在此处，我们以以太坊标准 <code>APIeth_sendTransaction</code>  为例向大家介绍一笔交易的具体构成，具体构成如下:</p>
<ul>
<li><code>type</code>  交易类型，如果使用 EIP1559 类型交易，则设置为 <code>0x02</code></li>
<li><code>nonce</code>  用户的 <code>nonce</code> ，此数值会在用户完成每一笔交易后增加 <code>1</code></li>
<li><code>to</code>  交易目标地址</li>
<li><code>from</code>  交易来源地址</li>
<li><code>gas</code>  即 <code>gas limit</code> ，具体参考<a target="_blank" rel="noopener" href="https://www.sai.show/2023/09/10/%E7%90%86%E8%A7%A3%E4%BB%A5%E5%A4%AA%E5%9D%8AGas-%E7%87%83%E6%96%99%E5%92%8C%E4%BA%A4%E6%98%93%E6%89%8B%E7%BB%AD%E8%B4%B9/#gas-limit-%E7%9A%84%E8%8E%B7%E5%8F%96"> Gas Limit</a> 的获取</li>
<li><code>value</code>  交易转账的 <code>ETH</code>  数量 (单位为 <code>wei</code> )</li>
<li><code>input</code>  交易包含的合约运行数据，如果交互对象不是合约，可置为 <code>0x</code></li>
<li><code>gasPrice</code>  如果使用 <code>EIP1559</code> ，此项可置为空</li>
<li><code>maxPriorityFeePerGas</code>  设置的<a target="_blank" rel="noopener" href="https://www.sai.show/2023/09/10/%E7%90%86%E8%A7%A3%E4%BB%A5%E5%A4%AA%E5%9D%8AGas-%E7%87%83%E6%96%99%E5%92%8C%E4%BA%A4%E6%98%93%E6%89%8B%E7%BB%AD%E8%B4%B9/#max-priority-fee"> Max Priority Fee</a></li>
<li><code>maxFeePerGas</code>  设置<a target="_blank" rel="noopener" href="https://www.sai.show/2023/09/10/%E7%90%86%E8%A7%A3%E4%BB%A5%E5%A4%AA%E5%9D%8AGas-%E7%87%83%E6%96%99%E5%92%8C%E4%BA%A4%E6%98%93%E6%89%8B%E7%BB%AD%E8%B4%B9/#max-fee"> Max Fee</a></li>
<li><code>accessList</code>  由 <code>EIP2930</code>  进行了一些规定，由于目前使用较少，我们不进行介绍</li>
<li><code>chainID</code>  链 ID，可通过<a target="_blank" rel="noopener" href="https://chainlist.org/"> ChainList</a> 获得相关数据</li>
</ul>
<p>接下来，我们尝试使用 <code>MetaMask</code>  提供的 API 构建一笔交易。</p>
<p>首先，我们需要任一已被 <code>MetaMask</code>  授权的网站进行测试。在此处我们以 <code>MetaMask</code>  的演示网站<a target="_blank" rel="noopener" href="https://metamask.github.io/test-dapp/"> MetaMask Test Dapp</a> 为例。点击 <code>CONNECT</code>  进行账户授权，授权完成后，可以点击 <code>ETH_ACCOUNTS</code>  与自己的地址进行对比。完成上述准备后，点击 <code>F12</code>  进入开发者模式后选择 <code>Console</code>  进入 <code>Javascript</code>  终端。</p>
<p>输入以下内容初始化交易参数:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const transactionParameters = &#123;</span><br><span class="line">  to: &#x27;0x0000000000000000000000000000000000000000&#x27;, </span><br><span class="line">  from: ethereum.selectedAddress, </span><br><span class="line">  value: &#x27;0x00&#x27;, </span><br><span class="line">  data:</span><br><span class="line">    &#x27;0x7f7465737432000000000000000000000000000000000000000000000000000000600057&#x27;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们在此处省略了很多字段，这些字段会被 <code>MetaMask</code>  自动补齐。</p>
<p>输入内容并运行:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const txHash = await ethereum.request(&#123;</span><br><span class="line">  method: &#x27;eth_sendTransaction&#x27;,</span><br><span class="line">  params: [transactionParameters],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果一切顺利，读者可以看到如下内容:</p>
<p><img src="https://img.gejiba.com/images/62fefc63e6ff21d1a32e1588b27a3861.png" alt=""></p>
<blockquote>
<p>如果读者需要设置 <code>gas</code> 、 <code>value</code>  等参数，需要注意这些参数均使用 <code>wei</code>  作为单位，同时使用 16 进制进行编码。1 wei 为  <code>0.000000000000000001 eth</code> 。</p>
</blockquote>
<p>更加详细的对于此 API 的说明，可以自行参考<a target="_blank" rel="noopener" href="https://docs.metamask.io/guide/sending-transactions.html">文档</a>或者前往<a target="_blank" rel="noopener" href="https://metamask.github.io/api-playground/api-documentation/"> MetaMask JSON-RPC API Reference</a></p>
<p>值得注意的是，大部分 RPC 服务商均不支持此 API。读者可以发现上述交易中不包含签名，但由于 RPC 服务商不托管用户私钥，不能对交易进行签名，所以不能进行交易提交。 <code>MetaMask</code>  钱包中包含用户私钥所以可以调用此函数。</p>
<blockquote>
<p>RPC 服务商一般允许使用 <code>eth_sendRawTransaction</code>  接口，此接口需要提交已经完成签名的并使用 RLP 编码的交易。本质上， <code>MetaMask</code>  也调用了此接口。</p>
</blockquote>
<p>如果希望通过命令行提交交易，可以使用 <code>Foundry</code>  提供的 <code>cast</code>  命令，具体可以参考<a target="_blank" rel="noopener" href="https://book.getfoundry.sh/reference/cast/cast-send"> cast send</a> 命令，支持上述所有参数。一个最简单的案例如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cast send 0x11475691C2CAA465E19F99c445abB31A4a64955C --value 0.001ether --gas-limit 21000 --gas-price 5gwei --priority-gas-price 1.5gwei --private-key $pk --rpc-url https://goerli.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161</span><br></pre></td></tr></table></figure>
<p>其中 <code>$pk</code>  需要替换为用户自己的私钥。 <code>--gas-price</code>  的含义为 <code>Max Fee</code> ， <code>--priority-gas-price</code>  含义为 <code>Max priority fee</code> ，详细介绍请参考上文给出的<a target="_blank" rel="noopener" href="https://book.getfoundry.sh/reference/cast/cast-send">文档</a>。</p>
<p>由于后文会使用到以太坊内的交易类型，在此处，我们一并给出交易在 <code>go-ethereum</code>  中的接口，如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">type TxData interface &#123;</span><br><span class="line">	txType() byte // returns the type ID</span><br><span class="line">	copy() TxData // creates a deep copy and initializes all fields</span><br><span class="line"></span><br><span class="line">	chainID() *big.Int</span><br><span class="line">	accessList() AccessList</span><br><span class="line">	data() []byte</span><br><span class="line">	gas() uint64</span><br><span class="line">	gasPrice() *big.Int</span><br><span class="line">	gasTipCap() *big.Int</span><br><span class="line">	gasFeeCap() *big.Int</span><br><span class="line">	value() *big.Int</span><br><span class="line">	nonce() uint64</span><br><span class="line">	to() *common.Address</span><br><span class="line"></span><br><span class="line">	rawSignatureValues() (v, r, s *big.Int)</span><br><span class="line">	setSignatureValues(chainID, v, r, s *big.Int)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>各个参数的含义如下:</p>
<ul>
<li><code>txType</code>  返回交易的类型，对应 <code>type</code>  参数</li>
<li><code>gasTipCap</code>  对应交易设置中的 <code>maxPriorityFeePerGas</code> ，即 <code>Max Priority Fee</code></li>
<li><code>gasFeeCap</code>  对应交易设置中的 <code>maxFeePerGas</code> ，即 <code>Max Fee</code></li>
</ul>
<p>其他参数较为简单，读者可以直接通过名称推断其含义，故不再进行介绍。</p>
<h2 id="交易池添加交易"><a class="markdownIt-Anchor" href="#交易池添加交易">#</a> 交易池添加交易</h2>
<p>当交易完成设置并通过 API 发送后，节点中的交易池会接受到此交易，并将其纳入自己的交易队列中。在详细分析交易进入队列之前，我们首先讨论一下以太坊中交易队列的类型。</p>
<p>在以太坊中，我们可以将交易队列使用以下 <code>Venn</code>  图表示:</p>
<p><img src="https://img.gejiba.com/images/f0f90a3e1b3781c822373519ab230ac5.png" alt=""></p>
<p>所有交易可以根据来源首先被划分为两类:</p>
<ol>
<li>本地交易  <code>local transaction</code></li>
<li>远程交易  <code>remote transaction</code></li>
</ol>
<p>正如前文所言，前者在优先级上高于后者所有交易，所以在以太坊交易池中属于最高等级，需要独立对待。</p>
<p>而远程交易 <code>remote transaction</code>  则被细分为了以下两个队列:</p>
<ol>
<li><code>pending</code>  队列 - 此队列数据基本可以保证会被纳入下一个区块，而在交易广播时也只广播此队列内的交易</li>
<li><code>queued</code>  队列 (亦称 <code>queue</code>  队列) - 此队列内的数据只能在交易池刷新队列时可能被纳入 <code>pending</code>  队列，我们会在后文进行介绍具体的更新规则</li>
</ol>
<blockquote>
<p>但在 <code>go-ethereum</code>  中，将 <code>local transaction</code>  保存在了 <code>pending</code>  队列中，但另一方面保证了 <code>local transaction</code>  不会被 <code>pending</code>  队列剔除</p>
</blockquote>
<p>在 <code>go-ethereum</code>  中，上述队列定义如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pending map[common.Address]*txList   // All currently processable transactions</span><br><span class="line">queue   map[common.Address]*txList   // Queued but non-processable transactions</span><br></pre></td></tr></table></figure>
<p>在正常情况下，当一个新的交易进入节点交易池后，此交易有以下去向:</p>
<ol>
<li>大部分情况下直接进入 <code>queue</code>  队列等待刷新</li>
<li>少部分用于增加 <code>gas</code>  费用的交易替换 <code>pending</code>  中的原有交易被纳入 <code>pending</code>  队列</li>
<li>因不满足交易条件而被删除</li>
</ol>
<p>我们首先分析用于在交易池中加入单个交易的 <code>add</code>  函数，其代码非常长，我们将逐块分析:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (pool *TxPool) add(tx *types.Transaction, local bool) (replaced bool, err error)</span><br></pre></td></tr></table></figure>
<p>函数定义说明，此函数接受交易和标识交易是否为本地交易的 <code>local</code>  标识符作为输入，返回代表此交易是否替换了其他交易的 <code>replaced</code>  标识和错误 <code>err</code></p>
<p>整个流程可以使用以下流程图说明:</p>
<p><img src="https://s-bj-3358-blog.oss.dogecdn.com/svg/txAdd.drawio.svg" alt=""></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hash := tx.Hash()</span><br><span class="line">if pool.all.Get(hash) != nil &#123;</span><br><span class="line">	log.Trace(&quot;Discarding already known transaction&quot;, &quot;hash&quot;, hash)</span><br><span class="line">	knownTxMeter.Mark(1)</span><br><span class="line">	return false, ErrAlreadyKnown</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先获得交易的哈希值，如果交易与交易池内的任何交易的哈希值相同，我们则丢弃此交易，并抛出异常</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isLocal := local || pool.locals.containsTx(tx)</span><br></pre></td></tr></table></figure>
<p>此代码判断交易是否为 <code>local transaction</code> 。如果满足 <code>local</code>  标识符为 <code>True</code>  或交易发送者位于 <code>Locals</code>  地址列表内条件，则认定此交易为 <code>local transaction</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if err := pool.validateTx(tx, isLocal); err != nil &#123;</span><br><span class="line">	log.Trace(&quot;Discarding invalid transaction&quot;, &quot;hash&quot;, hash, &quot;err&quot;, err)</span><br><span class="line">	invalidTxMeter.Mark(1)</span><br><span class="line">	return false, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>validateTx</code>  函数验证交易是否符合交易池的要求，限于篇幅，我们在此处直接给出 <code>validateTx</code>  函数验证的内容，具体代码实现请自行查找。具体验证内容如下:</p>
<ol>
<li>交易进行 <code>RLP</code>  编码后体积不大于 <code>131072 bytes</code></li>
<li>交易的 <code>Gas Limit</code>  不大于 3000 万 (即当前区块的 <code>GasLimit</code> )</li>
<li>交易的 <code>Max Fee</code>  和 <code>Max Priority Fee</code>  不大于 <code>2 ^ 256</code></li>
<li>交易的 <code>Max Priority Fee</code>  小于 <code>Max Fee</code></li>
<li>交易签名正确</li>
<li>交易的 <code>Max Priority Fee</code>  大于交易池设置的 <code>PriceLimit</code></li>
<li>交易的 <code>nonce</code>  大于交易者当前的 <code>nonce</code></li>
<li>交易者账户余额可以支付交易的 <code>Gas</code>  费用</li>
<li>满足 <code>AccessList</code>  的一些 <code>gas</code>  要求</li>
</ol>
<p>如果用户提交给节点的交易无法满足上述条件，则直接被丢弃。</p>
<p>当交易经过校验后，交易或被纳入 <code>queued</code>  或 <code>pending</code>  队列中，这一部分逻辑较为复杂。</p>
<p>首先，我们分析交易池容量已满的情况，我们使用以下的代码判定此情况:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint64(pool.all.Slots()+numSlots(tx)) &gt; pool.config.GlobalSlots+pool.config.GlobalQueue</span><br></pre></td></tr></table></figure>
<p>其中 <code>pool.all.Slots()</code>  会返回目前交易池内所有交易所占用的交易容量， <code>numSlots(tx)</code>  计算准备进入交易池的交易的所占用的交易容量，如果两者之和大于 <code>GlobalSlots</code>  (所有账户可执行交易的最大容量) 和 <code>GlobalQueue</code>  (全局最大非可执行交易容量)，我们可以判断交易池已满。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if !isLocal &amp;&amp; pool.priced.Underpriced(tx) &#123;</span><br><span class="line">	log.Trace(&quot;Discarding underpriced transaction&quot;, &quot;hash&quot;, hash, &quot;gasTipCap&quot;, tx.GasTipCap(), &quot;gasFeeCap&quot;, tx.GasFeeCap())</span><br><span class="line">	underpricedTxMeter.Mark(1)</span><br><span class="line">	return false, ErrUnderpriced</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处涉及到一个名词 <code>Reorg</code> ，此名词表示交易池重排。每当一个新的区块被生成，交易池会根据区块中的交易信息对交易池内的交易进行重组，包括在交易池内删除已被打包的交易 (这部分交易往往位于 <code>pending</code>  队列中)、升级符合条件的 <code>queued</code>  队列中的交易、在已满的队列中删除交易以及广播交易。该部分核心实现为 <code>runReorg</code>  函数，此函数会在后文多次出现。我们一般使用 <code>channel</code>  这种特殊的 go 数据类型与作为单独线程的 <code>runReorg</code>  函数进行通信。</p>
<p>在此代码中 <code>changesSinceReorg</code>  代表现在需要重组的交易数量，如果此交易数量大于 <code>GlobalQueue</code>  (所有账户可执行交易的最大容量) 的 <code>1 / 4</code> ，我们则认为交易池非常拥挤，直接丢弃新的交易。</p>
<blockquote>
<p>在交易池启动后，runReorg 函数会自动清除已满队列中的交易，开发者认为通过 add 函数删除太多交易并不合适，具体可参考<a target="_blank" rel="noopener" href="https://github.com/ethereum/go-ethereum/commit/d705f5a5543402a1d505bdc411d264cd4f883402"> #23095</a></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">drop, success := pool.priced.Discard(pool.all.Slots()-int(pool.config.GlobalSlots+pool.config.GlobalQueue)+numSlots(tx), isLocal)</span><br><span class="line"></span><br><span class="line">// Special case, we still can&#x27;t make the room for the new remote one.</span><br><span class="line">if !isLocal &amp;&amp; !success &#123;</span><br><span class="line">	log.Trace(&quot;Discarding overflown transaction&quot;, &quot;hash&quot;, hash)</span><br><span class="line">	overflowedTxMeter.Mark(1)</span><br><span class="line">	return false, ErrTxPoolOverflow</span><br><span class="line">&#125;</span><br><span class="line">// Bump the counter of rejections-since-reorg</span><br><span class="line">pool.changesSinceReorg += len(drop)</span><br><span class="line">// Kick out the underpriced remote transactions.</span><br><span class="line">for _, tx := range drop &#123;</span><br><span class="line">	log.Trace(&quot;Discarding freshly underpriced transaction&quot;, &quot;hash&quot;, tx.Hash(), &quot;gasTipCap&quot;, tx.GasTipCap(), &quot;gasFeeCap&quot;, tx.GasFeeCap())</span><br><span class="line">	underpricedTxMeter.Mark(1)</span><br><span class="line">	pool.removeTx(tx.Hash(), false)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们认为交易可以被删除，我们则进行真正的交易删除步骤。首先通过 <code>pool.priced.Discard</code>  函数移除占用 <code>pool.all.Slots()-int(pool.config.GlobalSlots+pool.config.GlobalQueue)+numSlots(tx)</code>  单位的交易容量的交易。此函数不会真正删除交易，而是会返回待删除交易的列表，待删除交易的筛选规则为交易由高到低进行排序，优先删除价格最低的交易 (本地交易不会被删除)。</p>
<p>如果无法获得待删除列表，且交易不是本地交易，则返回错误。如果获得待删除交易列表，我们会更新 <code>changesSinceReorg</code>  变量。然后使用 <code>pool.removeTx</code>  真正执行删除步骤。</p>
<p>当我们完成交易池容量方面的处理后，我们接下来处理一部分特殊的交易，即用于替换交易池 <code>pending</code>  队列的交易。这种替换交易往往用于增加已经在队列中的交易的 <code>gas</code> ，保证交易可以尽快完成。</p>
<p>我们可以通过以下代码判断此交易是否为替换交易:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from, _ := types.Sender(pool.signer, tx) // already validated</span><br><span class="line">if list := pool.pending[from]; list != nil &amp;&amp; list.Overlaps(tx)</span><br></pre></td></tr></table></figure>
<p>首先使用 <code>types.Sender(pool.signer, tx)</code>  获得交易的具体签名人，然后前往 <code>pool.pending</code>  队列中查询此用户名下的所有交易，并使用 <code>Overlaps</code>  函数判断交易是否存在重复。</p>
<blockquote>
<p><code>pool.pending</code>  是一个映射 <code>pending map[common.Address]*txList</code> ，我们可以通过用户地址在其内部快速检索相关交易</p>
</blockquote>
<p>当我们发现交易池内已包含此笔交易后，我们会尝试将交易加入交易池，代码如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inserted, old := list.Add(tx, pool.config.PriceBump)</span><br><span class="line">if !inserted &#123;</span><br><span class="line">	pendingDiscardMeter.Mark(1)</span><br><span class="line">	return false, ErrReplaceUnderpriced</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处使用到了 <code>Add</code>  函数，此函数接受交易 <code>tx</code>  后会在交易队列中查询与 <code>tx</code>  的 <code>nonce</code>  相同的交易。获得交易列表内的旧交易后，函数会校验 <code>gasTipCap</code>  和 <code>gasFeeCap</code>  相较于旧交易的增加幅度是否符合要求，如果满足上述条件，则直接在交易列表内替换旧的交易。同时返回需要替换的旧交易，以满足后续处理流程。当然，如果此处发现 <code>Add</code>  函数返回替换失败的标识，我们直接放弃替换。</p>
<p>关于 <code>Add</code>  函数，其具体代码如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">func (l *txList) Add(tx *types.Transaction, priceBump uint64) (bool, *types.Transaction) &#123;</span><br><span class="line">	// 获取交易列表内 Nonce 相同的旧交易</span><br><span class="line">	old := l.txs.Get(tx.Nonce())</span><br><span class="line">	if old != nil &#123;</span><br><span class="line">		// 要求新交易的 GasFeeCap 和 GasTipCap 大于旧交易</span><br><span class="line">		if old.GasFeeCapCmp(tx) &gt;= 0 || old.GasTipCapCmp(tx) &gt;= 0 &#123;</span><br><span class="line">			return false, nil</span><br><span class="line">		&#125;</span><br><span class="line">		// thresholdFeeCap = oldFC  * (100 + priceBump) / 100</span><br><span class="line">		a := big.NewInt(100 + int64(priceBump))</span><br><span class="line">		aFeeCap := new(big.Int).Mul(a, old.GasFeeCap())</span><br><span class="line">		aTip := a.Mul(a, old.GasTipCap())</span><br><span class="line"></span><br><span class="line">		// thresholdTip    = oldTip * (100 + priceBump) / 100</span><br><span class="line">		b := big.NewInt(100)</span><br><span class="line">		thresholdFeeCap := aFeeCap.Div(aFeeCap, b)</span><br><span class="line">		thresholdTip := aTip.Div(aTip, b)</span><br><span class="line"></span><br><span class="line">		// 要求新交易的 GasFeeCap 和 GasTipCapCmp 增加幅度大于 PriceBump</span><br><span class="line">		if tx.GasFeeCapIntCmp(thresholdFeeCap) &lt; 0 || tx.GasTipCapIntCmp(thresholdTip) &lt; 0 &#123;</span><br><span class="line">			return false, nil</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	// 使用新交易覆盖旧交易</span><br><span class="line">	l.txs.Put(tx)</span><br><span class="line"></span><br><span class="line">	// 以下内容为刷新参数</span><br><span class="line">	if cost := tx.Cost(); l.costcap.Cmp(cost) &lt; 0 &#123;</span><br><span class="line">		l.costcap = cost</span><br><span class="line">	&#125;</span><br><span class="line">	if gas := tx.Gas(); l.gascap &lt; gas &#123;</span><br><span class="line">		l.gascap = gas</span><br><span class="line">	&#125;</span><br><span class="line">	return true, old</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可能也发现上述流程仅对交易列表进行了替换，而不是对 <code>pool</code>  交易池的其他参数进行同步更新，所以我们使用以下代码更新交易池内的其他参数:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if old != nil &#123;</span><br><span class="line">	pool.all.Remove(old.Hash())</span><br><span class="line">	pool.priced.Removed(1)</span><br><span class="line">	pendingReplaceMeter.Mark(1)</span><br><span class="line">&#125;</span><br><span class="line">pool.all.Add(tx, isLocal)</span><br><span class="line">pool.priced.Put(tx, isLocal)</span><br><span class="line">pool.journalTx(from, tx)</span><br><span class="line">pool.queueTxEvent(tx)</span><br><span class="line">log.Trace(&quot;Pooled new executable transaction&quot;, &quot;hash&quot;, hash, &quot;from&quot;, from, &quot;to&quot;, tx.To())</span><br></pre></td></tr></table></figure>
<p>首先在用于维护交易池内所有交易的 <code>pool.all</code>  队列中删除此交易，同时在更新交易价格构成的 <code>pool.priced</code>  队列。使用 <code>pool.journalTx</code>  方法尝试将此替换交易纳入用于交易数据存储 <code>Journal</code>  内。</p>
<blockquote>
<p>此处使用了尝试是因为在 <code>journalTx</code>  函数中会对交易的 <code>from</code>  进行审查，如果交易不来自 <code>local</code>  地址，则不会进行存储。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">case tx := &lt;-pool.queueTxEventCh:</span><br><span class="line">	addr, _ := types.Sender(pool.signer, tx)</span><br><span class="line">	if _, ok := queuedEvents[addr]; !ok &#123;</span><br><span class="line">		queuedEvents[addr] = newTxSortedMap()</span><br><span class="line">	&#125;</span><br><span class="line">	queuedEvents[addr].Put(tx)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此处没有设置 <code>scheduleReorgLoop</code>  中的一个重要参数 <code>launchNextRun</code> ，此参数用于判断 <code>runReorg</code> ，即重排过程是否立即执行，若不设置，则意味着重排过程不会立即进行。</p>
</blockquote>
<p>而 <code>queueTxEvents</code>  定义如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queuedEvents  = make(map[common.Address]*txSortedMap)</span><br></pre></td></tr></table></figure>
<p>其中 <code>txSortedMap</code>  是一个 <code>nonce</code>  到交易 <code>transaction</code>  的堆 ( <code>heap</code> )。最终， <code>queuedEvents</code>  映射会被用于交易广播，以下给出的代码摘自 <code>runReorg</code>  函数的最后，其中 <code>events</code>  即此处的 <code>queuedEvents</code> 。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if len(events) &gt; 0 &#123;</span><br><span class="line">	var txs []*types.Transaction</span><br><span class="line">	for _, set := range events &#123;</span><br><span class="line">		txs = append(txs, set.Flatten()...)</span><br><span class="line">	&#125;</span><br><span class="line">	pool.txFeed.Send(NewTxsEvent&#123;txs&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成上述步骤后，我们会更新账户最新的活动时间，完成整个替换交易流程。代码如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pool.beats[from] = time.Now()</span><br><span class="line">return old != nil, nil</span><br></pre></td></tr></table></figure>
<p>如果一笔交易既不是对现有交易的替换，我们会使用使用以下代码直接将其推入 queue 队列中，代码如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">replaced, err = pool.enqueueTx(hash, tx, isLocal, true)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">	return false, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处的 <code>enqueueTx</code>  会将交易推送进入 <code>queue</code>  队列，限于篇幅，我们在此处以注释的形式解释此函数的源代码:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">func (pool *TxPool) enqueueTx(hash common.Hash, tx *types.Transaction, local bool, addAll bool) (bool, error) &#123;</span><br><span class="line">	from, _ := types.Sender(pool.signer, tx) // already validated</span><br><span class="line">	// 如果 queue 队列内没有此地址记录，则创建一个新的映射</span><br><span class="line">	// queue 的定义为 map[common.Address]*txList</span><br><span class="line">	if pool.queue[from] == nil &#123;</span><br><span class="line">		pool.queue[from] = newTxList(false)</span><br><span class="line">	&#125;</span><br><span class="line">	// 使用 (l *txList) Add 直接加入交易</span><br><span class="line">	// 详情请参考上文给出的代码解析</span><br><span class="line">	inserted, old := pool.queue[from].Add(tx, pool.config.PriceBump)</span><br><span class="line"></span><br><span class="line">	// 处理插入失败的情况</span><br><span class="line">	if !inserted &#123;</span><br><span class="line">		queuedDiscardMeter.Mark(1)</span><br><span class="line">		return false, ErrReplaceUnderpriced</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if old != nil &#123;</span><br><span class="line">		// 发生替换交易情况，刷新 pool 参数</span><br><span class="line">		// 类似上文提到的 替换交易 的后续处理</span><br><span class="line">		pool.all.Remove(old.Hash())</span><br><span class="line">		pool.priced.Removed(1)</span><br><span class="line">		queuedReplaceMeter.Mark(1)</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		// 没有发生替换交易的情况，增加计数器</span><br><span class="line">		// 计数器用于评估等功能</span><br><span class="line">		queuedGauge.Inc(1)</span><br><span class="line">	&#125;</span><br><span class="line">	// If the transaction isn&#x27;t in lookup set but it&#x27;s expected to be there,</span><br><span class="line">	// show the error log.</span><br><span class="line">	if pool.all.Get(hash) == nil &amp;&amp; !addAll &#123;</span><br><span class="line">		log.Error(&quot;Missing transaction in lookup set, please report the issue&quot;, &quot;hash&quot;, hash)</span><br><span class="line">	&#125;</span><br><span class="line">	// 刷新 pool 中的 all 和 priced 变量</span><br><span class="line">	if addAll &#123;</span><br><span class="line">		pool.all.Add(tx, local)</span><br><span class="line">		pool.priced.Put(tx, local)</span><br><span class="line">	&#125;</span><br><span class="line">	// 刷新交易账户的生命周期</span><br><span class="line">	if _, exist := pool.beats[from]; !exist &#123;</span><br><span class="line">		pool.beats[from] = time.Now()</span><br><span class="line">	&#125;</span><br><span class="line">	return old != nil, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成上述重要任务后，最后我们处理本地交易的问题，代码如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if local &amp;&amp; !pool.locals.contains(from) &#123;</span><br><span class="line">	log.Info(&quot;Setting new local account&quot;, &quot;address&quot;, from)</span><br><span class="line">	pool.locals.add(from)</span><br><span class="line">	pool.priced.Removed(pool.all.RemoteToLocals(pool.locals)) // Migrate the remotes if it&#x27;s marked as local first time.</span><br><span class="line">&#125;</span><br><span class="line">if isLocal &#123;</span><br><span class="line">	localGauge.Inc(1)</span><br><span class="line">&#125;</span><br><span class="line">pool.journalTx(from, tx)</span><br><span class="line"></span><br><span class="line">log.Trace(&quot;Pooled new future transaction&quot;, &quot;hash&quot;, hash, &quot;from&quot;, from, &quot;to&quot;, tx.To())</span><br><span class="line">return replaced, nil</span><br></pre></td></tr></table></figure>
<p>如果发现交易被标记为 <code>local</code> ，但账户没有被标记为 <code>local</code> ，则直接将交易发生账户列入 <code>locals</code>  名单内并对此地址下的所有交易进行提权至本地交易 ( <code>local transaction</code> )，最终使用 <code>journalTx</code>  存储本地交易。</p>
<p>当然，正常情况下我们更有可能一次性增加大量交易，所以在源代码中，我们可以看到大量函数都使用了 <code>addTxs</code>  函数，而此函数中的一个核心部分是 <code>addTxsLocked</code>  函数，我们首先介绍此函数。</p>
<p>代码如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func (pool *TxPool) addTxsLocked(txs []*types.Transaction, local bool) ([]error, *accountSet) &#123;</span><br><span class="line">	dirty := newAccountSet(pool.signer)</span><br><span class="line">	errs := make([]error, len(txs))</span><br><span class="line">	for i, tx := range txs &#123;</span><br><span class="line">		replaced, err := pool.add(tx, local)</span><br><span class="line">		errs[i] = err</span><br><span class="line">		if err == nil &amp;&amp; !replaced &#123;</span><br><span class="line">			dirty.addTx(tx)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	validTxMeter.Mark(int64(len(dirty.accounts)))</span><br><span class="line">	return errs, dirty</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处使用到了 <code>pool.add</code>  函数用于向交易池内增加交易，但为了方便使用 <code>runReorg</code>  函数进行交易重排，在此处定义了一个较为特殊的 <code>dirty</code>  变量，此变量为一个交易发送者地址列表，我们使用了 <code>dirty.addTx(tx)</code>  向此地址列表内增加新的交易发送者信息。</p>
<blockquote>
<p>此函数名内包含 <code>Locked</code>  字样，这意味着此函数必须在交易池拿到线程锁时才能使用</p>
</blockquote>
<p>我们也对此函数进行分析</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (pool *TxPool) addTxs(txs []*types.Transaction, local, sync bool) []error</span><br></pre></td></tr></table></figure>
<p>在此函数中，各参数含义如下:</p>
<ul>
<li><code>txs</code>  代表需要加入交易池的交易集合</li>
<li><code>local</code>  用于标识此交易集合内的交易是否为本地交易</li>
<li><code>sync</code>  用于标识此交易集合内的交易是否立即用于提权，用于测试</li>
</ul>
<p>此函数的流程图如下:</p>
<p><img src="https://s-bj-3358-blog.oss.dogecdn.com/svg/addTxs.drawio.svg" alt=""></p>
<p><code>addTxs</code>  函数首先对交易进行了一个简单的验证，具体代码如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">	errs = make([]error, len(txs))</span><br><span class="line">	news = make([]*types.Transaction, 0, len(txs))</span><br><span class="line">)</span><br><span class="line">for i, tx := range txs &#123;</span><br><span class="line">	// 验证交易是否已经存在在交易池内</span><br><span class="line">	if pool.all.Get(tx.Hash()) != nil &#123;</span><br><span class="line">		errs[i] = ErrAlreadyKnown</span><br><span class="line">		knownTxMeter.Mark(1)</span><br><span class="line">		continue</span><br><span class="line">	&#125;</span><br><span class="line">	// 验证交易签名是否正确</span><br><span class="line">	_, err := types.Sender(pool.signer, tx)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		errs[i] = ErrInvalidSender</span><br><span class="line">		invalidTxMeter.Mark(1)</span><br><span class="line">		continue</span><br><span class="line">	&#125;</span><br><span class="line">	// 将交易添加到 news 列表内</span><br><span class="line">	news = append(news, tx)</span><br><span class="line">&#125;</span><br><span class="line">if len(news) == 0 &#123;</span><br><span class="line">	return errs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在完成基本的交易校验后，使用 <code>pool.addTxsLocked</code>  函数将交易加入交易池内，代码如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pool.mu.Lock()</span><br><span class="line">newErrs, dirtyAddrs := pool.addTxsLocked(news, local)</span><br><span class="line">pool.mu.Unlock()</span><br></pre></td></tr></table></figure>
<p>此处使用了 <code>pool.mu.Lock()</code>  及 <code>pool.mu.Unlock()</code>  实现交易池线程锁定和解锁。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var nilSlot = 0</span><br><span class="line">for _, err := range newErrs &#123;</span><br><span class="line">	for errs[nilSlot] != nil &#123;</span><br><span class="line">		nilSlot++</span><br><span class="line">	&#125;</span><br><span class="line">	errs[nilSlot] = err</span><br><span class="line">	nilSlot++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个简单的 <code>for</code>  循环实现 <code>newErrs</code>  中的错误到 <code>err</code>  的转移。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">done := pool.requestPromoteExecutables(dirtyAddrs)</span><br><span class="line">if sync &#123;</span><br><span class="line">	&lt;-done</span><br><span class="line">&#125;</span><br><span class="line">return errs</span><br></pre></td></tr></table></figure>
<p>此函数实际上实现了将交易通过 <code>channel</code>  推送给 <code>runReorg</code>  的作用。其中 <code>requestPromoteExecutables</code>  的定义如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func (pool *TxPool) requestPromoteExecutables(set *accountSet) chan struct&#123;&#125; &#123;</span><br><span class="line">	select &#123;</span><br><span class="line">	case pool.reqPromoteCh &lt;- set:</span><br><span class="line">		return &lt;-pool.reorgDoneCh</span><br><span class="line">	case &lt;-pool.reorgShutdownCh:</span><br><span class="line">		return pool.reorgShutdownCh</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="交易重排"><a class="markdownIt-Anchor" href="#交易重排">#</a> 交易重排</h2>
<p><code>runReorg</code>  函数是由 <code>scheduleReorgLoop</code>  函数启动，而 <code>scheduleReorgLoop</code>  函数在交易池初始化时就被调用，具体可以参考 <code>NewTxPool</code>  函数中的下述代码:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go pool.scheduleReorgLoop()</span><br></pre></td></tr></table></figure>
<p>而在 <code>scheduleReorgLoop</code>  函数内，我们可以看到大量的 channel 的使用。</p>
<p>我们首先给出一系列的 <code>channel</code>  定义:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">reqResetCh      chan *txpoolResetRequest</span><br><span class="line">reqPromoteCh    chan *accountSet</span><br><span class="line">queueTxEventCh  chan *types.Transaction</span><br><span class="line">reorgDoneCh     chan chan struct&#123;&#125;</span><br><span class="line">reorgShutdownCh chan struct&#123;&#125;  // requests shutdown of scheduleReorgLoop</span><br></pre></td></tr></table></figure>
<p>其传输的信息主要为:</p>
<ul>
<li><code>reqResetCh</code>  传输用于区块更新的相关信息</li>
<li><code>reqPromoteCh</code>  传输用于更新的指定地址集合</li>
<li><code>queueTxEventCh</code>  传输用于加入 <code>queued</code>  队列交易的信息</li>
<li><code>reorgDoneCh</code>  传输由空结构体构成的 <code>channel</code></li>
<li><code>reorgShutdownCh</code>  传输 <code>reorg</code>  停止信号</li>
</ul>
<p>一个简单的示例图，如下:</p>
<p><img src="https://s-bj-3358-blog.oss.dogecdn.com/svg/scheduleReorgLoop.drawio.svg" alt=""></p>
<p>在这些 <code>channel</code>  中，较难理解的是 <code>reorgDoneCh</code>  和 <code>reorgShutdownCh</code> ，这两个变量的设计是为了保证并发的正确性。我们首先介绍 <code>reorgDoneCh</code>  变量，此变量非常奇怪属于 <code>chan chan struct&#123;&#125;</code>  类型。</p>
<p>对于任何一个 channel，分析其作用的最好方法就是分析其数据发送者和数据接收者。 <code>reorgDoneCh</code>  的数据发送者代码如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">case req := &lt;-pool.reqResetCh:</span><br><span class="line">	// Reset request: update head if request is already pending.</span><br><span class="line">	if reset == nil &#123;</span><br><span class="line">		reset = req</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		reset.newHead = req.newHead</span><br><span class="line">	&#125;</span><br><span class="line">	launchNextRun = true</span><br><span class="line">	pool.reorgDoneCh &lt;- nextDone</span><br><span class="line"></span><br><span class="line">case req := &lt;-pool.reqPromoteCh:</span><br><span class="line">	// Promote request: update address set if request is already pending.</span><br><span class="line">	if dirtyAccounts == nil &#123;</span><br><span class="line">		dirtyAccounts = req</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		dirtyAccounts.merge(req)</span><br><span class="line">	&#125;</span><br><span class="line">	launchNextRun = true</span><br><span class="line">	pool.reorgDoneCh &lt;- nextDone</span><br></pre></td></tr></table></figure>
<p>上述代码均来自 <code>scheduleReorgLoop</code>  函数内，我们可以看到都是在进行一系列数据处理后在进行推送 <code>nextDone</code> 。其中 <code>nextDone</code>  的定义为 <code>make(chan struct&#123;&#125;)</code> ，是符合 <code>channel</code>  的类型要求的。</p>
<blockquote>
<p>上文给出的 <code>case</code>  代码块内，我们可以看到 <code>launchNextRun</code>  被设置为 <code>true</code> ，这意味着重排会立即进行。当然，此时进行的重排也会对上文介绍的 <code>queuedEvents</code>  中的内容一并进行重排。</p>
</blockquote>
<p>我们进一步分析数据接收者，代码如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func (pool *TxPool) requestReset(oldHead *types.Header, newHead *types.Header) chan struct&#123;&#125; &#123;</span><br><span class="line">	select &#123;</span><br><span class="line">	case pool.reqResetCh &lt;- &amp;txpoolResetRequest&#123;oldHead, newHead&#125;:</span><br><span class="line">		return &lt;-pool.reorgDoneCh</span><br><span class="line">	case &lt;-pool.reorgShutdownCh:</span><br><span class="line">		return pool.reorgShutdownCh</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (pool *TxPool) requestPromoteExecutables(set *accountSet) chan struct&#123;&#125; &#123;</span><br><span class="line">	select &#123;</span><br><span class="line">	case pool.reqPromoteCh &lt;- set:</span><br><span class="line">		return &lt;-pool.reorgDoneCh</span><br><span class="line">	case &lt;-pool.reorgShutdownCh:</span><br><span class="line">		return pool.reorgShutdownCh</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些接收函数均直接选择 <code>将pool.reorgDoneCh</code>  内的空 <code>channel</code>  作为 <code>return</code>  返回，如果读者进一步研究这两个函数的应用会发现函数的 <code>return</code>  值并没有被具体的运行逻辑使用。</p>
<p>造成这种情况的原因是 <code>reorgDoneCh</code>  的目的仅是保证 <code>reqResetCh</code>  和 <code>reqPromoteCh</code>  函数发送给 <code>reqResetCh</code>  和 <code>reqPromoteCh</code>  的数据会被 <code>scheduleReorgLoop</code>  正确处理后关闭。更加详细的解释是当我们通过 <code>return &lt;-pool.reorgDoneCh</code>  获得一个 <code>channel</code>  (即 <code>nextDone</code> ) 时，由于 <code>channel</code>  自身具有阻塞性，主函数只有在 <code>scheduleReorgLoop</code>  进行完数据处理 (即上文给出的 <code>case</code>  块) 运行后退出。这一行为有效保障函数运行的同步。这种运行逻辑与 <code>async/await</code>  类似，在 <code>golang</code>  中，类似 <code>reorgDoneCh</code>  的 <code>chan chan struct&#123;&#125;</code>  是一种重要的无锁队列结构，</p>
<blockquote>
<p>假如我们不进行 <code>reorgDoneCh</code>  队列操作，那么使用 <code>requestPromoteExecutables</code>  的 <code>addTxs</code>  函数就可以无视 <code>scheduleReorgLoop</code>  的数据处理流程而自行工作，这可能导致数据在 <code>scheduleReorgLoop</code>  进行数据处理操作时被推入函数，造成并发冲突。</p>
</blockquote>
<blockquote>
<p><code>reorgDoneCh</code>  代表的 <code>chan chan struct&#123;&#125;</code>  是 无锁 Channel 的重要实现方式，其他实现方式可以参考<a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1yIAYmbvL3JxOKOjuCyon7JhW4cSv1wy5hC0ApeGMV9s/pub"> Go channels on steroids</a>。如果读者想进一步深入学习，建议阅读<a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel/#%E6%97%A0%E9%94%81%E7%AE%A1%E9%81%93"> Go 语言设计与实现</a>。</p>
</blockquote>
<h2 id="区块打包"><a class="markdownIt-Anchor" href="#区块打包">#</a> 区块打包</h2>
<p>在完成交易进入交易池、交易提升至 <code>pending</code>  队列后，我们需要处理区块打包问题，考虑到文章的专题性，本节不会讨论以下问题:</p>
<ol>
<li>区块的具体结构和生成方法</li>
<li><code>PoS</code>  共识算法</li>
</ol>
<p>本节仅关注交易池与区块打包的对接部分。此部分主要位于 <code>miner/worker.go</code>  文件内，我们所需要介绍内容的核心函数为 <code>fillTransactions</code> ，代码如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">func (w *worker) fillTransactions(interrupt *int32, env *environment) error &#123;</span><br><span class="line">	// Split the pending transactions into locals and remotes</span><br><span class="line">	// Fill the block with all available pending transactions.</span><br><span class="line">	pending := w.eth.TxPool().Pending(true)</span><br><span class="line">	localTxs, remoteTxs := make(map[common.Address]types.Transactions), pending</span><br><span class="line">	for _, account := range w.eth.TxPool().Locals() &#123;</span><br><span class="line">		if txs := remoteTxs[account]; len(txs) &gt; 0 &#123;</span><br><span class="line">			delete(remoteTxs, account)</span><br><span class="line">			localTxs[account] = txs</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if len(localTxs) &gt; 0 &#123;</span><br><span class="line">		txs := types.NewTransactionsByPriceAndNonce(env.signer, localTxs, env.header.BaseFee)</span><br><span class="line">		if err := w.commitTransactions(env, txs, interrupt); err != nil &#123;</span><br><span class="line">			return err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if len(remoteTxs) &gt; 0 &#123;</span><br><span class="line">		txs := types.NewTransactionsByPriceAndNonce(env.signer, remoteTxs, env.header.BaseFee)</span><br><span class="line">		if err := w.commitTransactions(env, txs, interrupt); err != nil &#123;</span><br><span class="line">			return err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一部分代码中使用了 <code>types.NewTransactionsByPriceAndNonce</code>  函数。调用此函数会构造以下类型:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type TransactionsByPriceAndNonce struct &#123;</span><br><span class="line">	txs     map[common.Address]Transactions // Per account nonce-sorted list of transactions</span><br><span class="line">	heads   TxByPriceAndTime                // Next transaction for each unique account (price heap)</span><br><span class="line">	signer  Signer                          // Signer for the set of transactions</span><br><span class="line">	baseFee *big.Int                        // Current base fee</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中， <code>heads</code>  属于 <code>TxByPriceAndTime</code>  类型构成堆 ( <code>heap</code> )，其具体定义为 <code>[]*TxWithMinerFee</code> ，进一步 <code>TxWithMinerFee</code>  的定义如下:</p>
<p>此处出现了一个变量 <code>minerFee</code> ，此变量与 <code>gas</code>  费用有关，其具体的计算公式如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">min(GasTipCap, gasFeeCap-baseFee)</span><br><span class="line">等价于</span><br><span class="line">min(maxPriorityFeePerGas, maxFeePerGas-BaseFee)</span><br></pre></td></tr></table></figure>
<p>在后文中，我们经常使用 <code>func (*TransactionsByPriceAndNonce).Pop()</code>  函数，此函数会返回交易队列中 <code>minerFee</code>  最大的交易，如果 <code>minerFee</code>  相同则返回发现时间较早的交易。</p>
<p>在完成 <code>NewTransactionsByPriceAndNonce</code>  函数后，我们将使用 <code>commitTransactions</code>  函数，此函数在本节中属于核心地位，我们将着重介绍。</p>
<p>此函数的定义如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (w *worker) commitTransactions(env *environment, txs *types.TransactionsByPriceAndNonce, interrupt *int32) error</span><br></pre></td></tr></table></figure>
<p>在此处，我们忽略用于用于传输中断信息的 <code>interrupt</code>  变量，而另一个变量 <code>env</code>  则存储有封装区块所需要的一系列其他参数，在此次我们仍将省略不谈。</p>
<p>接下来，我们分析其代码构成:</p>
<p>第一步，初始化 <code>gas pool</code> ，并限定区块可用 <code>gas</code> ，代码如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gasLimit := env.header.GasLimit</span><br><span class="line">if env.gasPool == nil &#123;</span><br><span class="line">	env.gasPool = new(core.GasPool).AddGas(gasLimit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，函数 <code>AddGas</code>  的功能是提供 <code>gas</code>  限额。关于区块的 <code>GasLimit</code>  的讨论，可以参考<a target="_blank" rel="noopener" href="https://www.sai.show/2023/09/10/%E7%90%86%E8%A7%A3%E4%BB%A5%E5%A4%AA%E5%9D%8AGas-%E7%87%83%E6%96%99%E5%92%8C%E4%BA%A4%E6%98%93%E6%89%8B%E7%BB%AD%E8%B4%B9">以太坊 Gas 燃料和交易手续费</a>计算中的内容。</p>
<p>接下来，我们会进入到一个 <code>for</code>  循环，此循环没有限定条件，仅能依靠循环体内的 <code>break</code>  跳出。</p>
<p>在此循环内首先检查了 <code>interrupt</code>  变量，我们跳过此部分。然后，检查了 <code>gasPool</code>  的余额，代码如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if env.gasPool.Gas() &lt; params.TxGas &#123;</span><br><span class="line">	log.Trace(&quot;Not enough gas for further transactions&quot;, &quot;have&quot;, env.gasPool, &quot;want&quot;, params.TxGas)</span><br><span class="line">	break</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果检测到 <code>gasPool</code>  内的 <code>gas</code>  剩余小于 <code>21000</code> ，我们认为已达到区块的 <code>gasLimit</code> ，跳出循环。</p>
<p>检测完 <code>gas</code>  限制后，我们进一步检测交易队列的情况，若此笔交易位于队列最后，则退出循环。代码如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tx := txs.Peek()</span><br><span class="line">if tx == nil &#123;</span><br><span class="line">	break</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，tx.Peek () 会返回 TransactionsByPriceAndNonce 堆中的下一个元素，但与 pop 不同的是此操作不会影响堆的结构。</p>
<p>在完成上述步骤后，我们对一项非常重要的参数进行校验，即判断交易的签名是否符合 <code>EIP155</code>  的规定。</p>
<p>如果交易不符合 EIP155 的规定，交易会不配剔除打包序列。</p>
<p>完成基本的校验后，我们准备执行交易，执行交易的代码如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">env.state.Prepare(tx.Hash(), env.tcount)</span><br><span class="line"></span><br><span class="line">logs, err := w.commitTransaction(env, tx)</span><br></pre></td></tr></table></figure>
<p>在此段代码内，我们首先初始化 <code>state</code> ，即用来记录状态变化的数据库。在第二行里，我们通过 <code>commitTransaction</code>  正式提交交易。运行交易步骤包含大量的函数调用，限于篇幅，我们无法完整介绍。在此处，我们仅给出一系列函数调用中最核心的代码，如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if contractCreation &#123;</span><br><span class="line">	ret, _, st.gas, vmerr = st.evm.Create(sender, st.data, st.gas, st.value)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	// Increment the nonce for the next transaction</span><br><span class="line">	st.state.SetNonce(msg.From(), st.state.GetNonce(sender.Address())+1)</span><br><span class="line">	ret, st.gas, vmerr = st.evm.Call(sender, st.to(), st.data, st.gas, st.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果交易涉及合约创建，则调用 <code>st.evm.Create</code> ，否则则调用 <code>st.evm.Call</code>  函数，所以即使交易仅是一笔转账交易，以太坊节点依旧会调用 <code>EVM</code> ，这与一般的认识是不相符的。</p>
<p>完成交易提交后，我们通过 <code>switch</code>  语句处理交易运行失败的各种情况，读者可以阅读相关代码。如果一切正常，我们运行以下代码块:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">case errors.Is(err, nil):</span><br><span class="line">	// Everything ok, collect the logs and shift in the next transaction from the same account</span><br><span class="line">	coalescedLogs = append(coalescedLogs, logs...)</span><br><span class="line">	env.tcount++</span><br><span class="line">	txs.Shift()</span><br></pre></td></tr></table></figure>
<p>此代码会将日志推送到 <code>coalescedLogs</code>  日志中，然后运行 <code>tx.Shift()</code>  执行下一个交易。</p>
<p>在完成交易的执行后，我们使用以下代码将运行日志作为订阅源供用户使用:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if !w.isRunning() &amp;&amp; len(coalescedLogs) &gt; 0 &#123;</span><br><span class="line">	cpy := make([]*types.Log, len(coalescedLogs))</span><br><span class="line">	for i, l := range coalescedLogs &#123;</span><br><span class="line">		cpy[i] = new(types.Log)</span><br><span class="line">		*cpy[i] = *l</span><br><span class="line">	&#125;</span><br><span class="line">	w.pendingLogsFeed.Send(cpy)</span><br><span class="line">&#125;</span><br><span class="line">return nil</span><br></pre></td></tr></table></figure>
<p>我们首先对 <code>coalescedLogs</code>  进行复制，然后直接使用 <code>Send</code>  发送订阅源。此订阅源并不是在广播交易，而只是供终端用户使用。</p>
<p>在进行使用前，请确保拥有一个 <code>ws</code>  以太坊节点，在此处，我们使用了 <code>infura</code>  提供的服务。除此之外，读者应安装 <code>ws</code>  的客户端，在此处，我使用了 <code>utws</code>  作为客户端。输入以下命令:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uwsc wss://mainnet.infura.io/ws/v3/YOUR_API_KEY</span><br></pre></td></tr></table></figure>
<p>回车后，在 <code>&gt;</code>  后键入以下内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;jsonrpc&quot;:&quot;2.0&quot;, &quot;id&quot;: 1, &quot;method&quot;: &quot;eth_subscribe&quot;, &quot;params&quot;: [&quot;newPendingTransactions&quot;]&#125;</span><br></pre></td></tr></table></figure>
<p>输入如下图:</p>
<p><img src="https://img.gejiba.com/images/16165ef03287c0a1f62ed2fa56d147ed.png" alt=""></p>
<p>输出如下图:</p>
<p><img src="https://img.gejiba.com/images/546871eeed9c3dc3e6785630836f2156.png" alt=""></p>
<p>在输出中， <code>result</code>  代表交易的哈希值，读者可 https://etherscan.io/tx/{result} 形式的网址访问到交易详情。</p>
<p>最后，我们介绍用于区块密封的函数，代码如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func (w *worker) generateWork(params *generateParams) (*types.Block, error) &#123;</span><br><span class="line">	work, err := w.prepareWork(params)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	defer work.discard()</span><br><span class="line"></span><br><span class="line">	if !params.noTxs &#123;</span><br><span class="line">		interrupt := new(int32)</span><br><span class="line">		timer := time.AfterFunc(w.newpayloadTimeout, func() &#123;</span><br><span class="line">			atomic.StoreInt32(interrupt, commitInterruptTimeout)</span><br><span class="line">		&#125;)</span><br><span class="line">		defer timer.Stop()</span><br><span class="line"></span><br><span class="line">		err := w.fillTransactions(interrupt, work)</span><br><span class="line">		if errors.Is(err, errBlockInterruptedByTimeout) &#123;</span><br><span class="line">			log.Warn(&quot;Block building is interrupted&quot;, &quot;allowance&quot;, common.PrettyDuration(w.newpayloadTimeout))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return w.engine.FinalizeAndAssemble(w.chain, work.header, work.state, work.txs, work.unclelist(), work.receipts)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目前以太坊已经完成了合并，所以此处最终的出块是由 <code>engine</code>  完成，即共识引擎。</p>
<p>简单给出一个当前以太坊的节点架构图:</p>
<p><img src="https://img.gejiba.com/images/83779fa7aa66b0a16853c39d8cf281a6.png" alt=""></p>
<p>简单来说，当共识客户端 ( <code>Consensus Client</code> ) 被选为区块提案者 ( <code>proposer</code> ) 后，会在执行客户端 ( <code>Exection Client</code> ) 的交易池内筛选交易，并由执行客户端运行交易。最终，共识客户端将打包后的交易进行广播，由其他节点进行投票，最终确定一个区块。</p>
<p>在此处，我们基本完成了一笔交易在以太坊执行层内的完整流程，接下来，我们介绍当区块到达交易池后，交易池重构的相关内容。</p>
<h2 id="交易池重构"><a class="markdownIt-Anchor" href="#交易池重构">#</a> 交易池重构</h2>
<p>我们在上文仅考虑了节点直接生产区块的区块，但在实际情况中，节点更有可能无法生产区块，而仅仅作为区块的接受方，接受其他节点生产的区块。我们势必限需要讨论节点在接受到其他节点发送的区块时如何进行交易池重构的问题 。</p>
<p>在交易池主循环内，我们可以找到如下代码:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">case ev := &lt;-pool.chainHeadCh:</span><br><span class="line">	if ev.Block != nil &#123;</span><br><span class="line">		pool.requestReset(head.Header(), ev.Block.Header())</span><br><span class="line">		head = ev.Block</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>当交易池在 <code>chainHeadCh</code>  内获得新的区块头后，交易池会启动 <code>requestReset</code>  函数，此函数我们在上文已有所介绍， <code>requestReset</code>  函数会将请求发送到 <code>reqResetCh</code>  的通道内，最终由 <code>scheduleReorgLoop</code>  函数接受，代码如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">case req := &lt;-pool.reqResetCh:</span><br><span class="line">	// Reset request: update head if request is already pending.</span><br><span class="line">	if reset == nil &#123;</span><br><span class="line">		reset = req</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		reset.newHead = req.newHead</span><br><span class="line">	&#125;</span><br><span class="line">	launchNextRun = true</span><br><span class="line">	pool.reorgDoneCh &lt;- nextDone</span><br></pre></td></tr></table></figure>
<p>实际最终还是由 <code>runReorg</code>  运行，我们在此处仅接受上文未介绍的 Reset 部分，第一部分的代码如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">if reset != nil &#123;</span><br><span class="line">	// Reset from the old head to the new, rescheduling any reorged transactions</span><br><span class="line">	pool.reset(reset.oldHead, reset.newHead)</span><br><span class="line"></span><br><span class="line">	// Nonces were reset, discard any events that became stale</span><br><span class="line">	for addr := range events &#123;</span><br><span class="line">		events[addr].Forward(pool.pendingNonces.get(addr))</span><br><span class="line">		if events[addr].Len() == 0 &#123;</span><br><span class="line">			delete(events, addr)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	// Reset needs promote for all addresses</span><br><span class="line">	promoteAddrs = make([]common.Address, 0, len(pool.queue))</span><br><span class="line">	for addr := range pool.queue &#123;</span><br><span class="line">		promoteAddrs = append(promoteAddrs, addr)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们首先介绍除了 <code>reset</code>  外的其他部分，在完成 <code>reset</code>  函数后，我们首先删除 <code>events</code>  (内部含有准备加入 <code>quenue</code>  队列的交易) 内所有小于当前状态数据内的 <code>nonce</code>  的交易。小于当前状态数据库内的 nonce 意味着此交易已被打包，不需要进行进一步处理。</p>
<p>然后，我们将当前交易池内 <code>quenue</code>  队列中的所有交易列入 <code>promoteAddrs</code>  中，这意味着在之后的代码运行中，这些交易均会被升级为 <code>pending</code>  队列内的交易。</p>
<p>最后，我们介绍较为复杂的 <code>reset</code>  函数，此函数负责向交易池内提交差异交易，而不负责删除交易，删除交易的代码我们会在第二部分进行介绍。</p>
<p>我们首先介绍第一个 <code>if</code>  语句内的交易:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">if oldHead != nil &amp;&amp; oldHead.Hash() != newHead.ParentHash &#123;</span><br><span class="line">	// 获得区块编号</span><br><span class="line">	oldNum := oldHead.Number.Uint64()</span><br><span class="line">	newNum := newHead.Number.Uint64()</span><br><span class="line">	// 当新旧区块差异过大时，不进行处理</span><br><span class="line">	// 此种区块一般发生在节点同步数据时</span><br><span class="line">	if depth := uint64(math.Abs(float64(oldNum) - float64(newNum))); depth &gt; 64 &#123;</span><br><span class="line">		log.Debug(&quot;Skipping deep transaction reorg&quot;, &quot;depth&quot;, depth)</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		// 声明需要丢弃和包含的交易</span><br><span class="line">		var discarded, included types.Transactions</span><br><span class="line">		var (</span><br><span class="line">			// 获取区块完整数据</span><br><span class="line">			rem = pool.chain.GetBlock(oldHead.Hash(), oldHead.Number.Uint64())</span><br><span class="line">			add = pool.chain.GetBlock(newHead.Hash(), newHead.Number.Uint64())</span><br><span class="line">		)</span><br><span class="line">		if rem == nil &#123;</span><br><span class="line">			// 此情况属于特殊情况，即旧区块无法检索</span><br><span class="line">			if newNum &gt;= oldNum &#123;</span><br><span class="line">				log.Warn(&quot;Transaction pool reset with missing oldhead&quot;,</span><br><span class="line">					&quot;old&quot;, oldHead.Hash(), &quot;oldnum&quot;, oldNum, &quot;new&quot;, newHead.Hash(), &quot;newnum&quot;, newNum)</span><br><span class="line">				return</span><br><span class="line">			&#125;</span><br><span class="line">			log.Debug(&quot;Skipping transaction reset caused by setHead&quot;,</span><br><span class="line">				&quot;old&quot;, oldHead.Hash(), &quot;oldnum&quot;, oldNum, &quot;new&quot;, newHead.Hash(), &quot;newnum&quot;, newNum)</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			for rem.NumberU64() &gt; add.NumberU64() &#123;</span><br><span class="line">				discarded = append(discarded, rem.Transactions()...)</span><br><span class="line">				if rem = pool.chain.GetBlock(rem.ParentHash(), rem.NumberU64()-1); rem == nil &#123;</span><br><span class="line">					log.Error(&quot;Unrooted old chain seen by tx pool&quot;, &quot;block&quot;, oldHead.Number, &quot;hash&quot;, oldHead.Hash())</span><br><span class="line">					return</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			for add.NumberU64() &gt; rem.NumberU64() &#123;</span><br><span class="line">				included = append(included, add.Transactions()...)</span><br><span class="line">				if add = pool.chain.GetBlock(add.ParentHash(), add.NumberU64()-1); add == nil &#123;</span><br><span class="line">					log.Error(&quot;Unrooted new chain seen by tx pool&quot;, &quot;block&quot;, newHead.Number, &quot;hash&quot;, newHead.Hash())</span><br><span class="line">					return</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			for rem.Hash() != add.Hash() &#123;</span><br><span class="line">				discarded = append(discarded, rem.Transactions()...)</span><br><span class="line">				if rem = pool.chain.GetBlock(rem.ParentHash(), rem.NumberU64()-1); rem == nil &#123;</span><br><span class="line">					log.Error(&quot;Unrooted old chain seen by tx pool&quot;, &quot;block&quot;, oldHead.Number, &quot;hash&quot;, oldHead.Hash())</span><br><span class="line">					return</span><br><span class="line">				&#125;</span><br><span class="line">				included = append(included, add.Transactions()...)</span><br><span class="line">				if add = pool.chain.GetBlock(add.ParentHash(), add.NumberU64()-1); add == nil &#123;</span><br><span class="line">					log.Error(&quot;Unrooted new chain seen by tx pool&quot;, &quot;block&quot;, newHead.Number, &quot;hash&quot;, newHead.Hash())</span><br><span class="line">					return</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			reinject = types.TxDifference(discarded, included)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在源代码中给出了部分注释，但对于一些特殊情况，我们在此进行解释。</p>
<p><code>rem == nil</code>  情况，此情况较为特殊，我们无法在数据库内检索到旧的区块，此种情况可细分:</p>
<ol>
<li><code>newNum &gt;= oldNum</code>  新区块编号大于或等于旧区块，此种情况下意味着我们之前使用的链并不位于主链上，而是位于分支链上。此种情况下，我们不需要对交易池进行特别处理，等待再获得一个区块重置变量即可。</li>
<li>其他情况，这些情况都较为玄学，可能是函数运行出现问题，也可以通过等待区块重置变量解决问题</li>
</ol>
<p>除了上面这种情况，我们还会遇到以下情况:</p>
<ol>
<li>
<p>旧区块大于新区块 这意味着节点获得了一个可能来自分支链的块广播，我们将旧区块的交易列入 <code>discarded</code>  序列内。正如上文所述，此函数其实不会丢弃交易， <code>discarded</code>  仅作为交易序列名存在。我们认为旧区块内的交易都应该删除，无论旧区块是否位于主分支等情况</p>
</li>
<li>
<p>新区块大于旧区块 正常情况，将新区块内的交易列入 <code>included</code>  列表内</p>
</li>
</ol>
<blockquote>
<p>在当前以太坊 <code>PoS</code>  情况下，很难出现分支链等情况</p>
</blockquote>
<p>当然，只要新区块与旧区块的哈希值不同，我们就需要处理其内部的交易，即 <code>rem.Hash() != add.Hash()</code>  情况，在这种情况下，我们将旧区块内的交易列入 <code>discarded</code> ，并将新区块内的交易列入 <code>included</code> 。我们也做了两个校验，代码如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rem = pool.chain.GetBlock(rem.ParentHash(), rem.NumberU64()-1); rem == nil</span><br></pre></td></tr></table></figure>
<p>上述代码用于判断旧区块是否存在上一个区块，如果没有，则说明此区块不可信，应该直接抛弃。</p>
<p>还有一种极其特殊的情况，代码如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if newHead == nil &#123;</span><br><span class="line">	newHead = pool.chain.CurrentBlock().Header() // Special case during testing</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如注释，此情况仅用于测试。</p>
<p>在完成上述步骤后，我们通过 <code>reinject = types.TxDifference(discarded, included)</code>  获得两个区块交易集合之间的差集。这也是我们需要补充到交易池内的交易，并同时根据新的区块更新部分设置，代码如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">statedb, err := pool.chain.StateAt(newHead.Root)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">	log.Error(&quot;Failed to reset txpool state&quot;, &quot;err&quot;, err)</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br><span class="line">pool.currentState = statedb</span><br><span class="line">pool.pendingNonces = newTxNoncer(statedb)</span><br><span class="line">pool.currentMaxGas = newHead.GasLimit</span><br><span class="line"></span><br><span class="line">// Inject any transactions discarded due to reorgs</span><br><span class="line">log.Debug(&quot;Reinjecting stale transactions&quot;, &quot;count&quot;, len(reinject))</span><br><span class="line">senderCacher.recover(pool.signer, reinject)</span><br><span class="line">pool.addTxsLocked(reinject, false)</span><br><span class="line"></span><br><span class="line">// Update all fork indicator by next pending block number.</span><br><span class="line">next := new(big.Int).Add(newHead.Number, big.NewInt(1))</span><br><span class="line">pool.istanbul = pool.chainconfig.IsIstanbul(next)</span><br><span class="line">pool.eip2718 = pool.chainconfig.IsBerlin(next)</span><br><span class="line">pool.eip1559 = pool.chainconfig.IsLondon(next)</span><br></pre></td></tr></table></figure>
<p>上述内容基本就是根据新区块对各个变量进行重新设置，较为简单，不再赘述。</p>
<p>接下来，我们分析 runReorg 的第二部分，此部分会删除部分交易。代码如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if reset != nil &#123;</span><br><span class="line">	pool.demoteUnexecutables()</span><br><span class="line">	if reset.newHead != nil &amp;&amp; pool.chainconfig.IsLondon(new(big.Int).Add(reset.newHead.Number, big.NewInt(1))) &#123;</span><br><span class="line">		pendingBaseFee := misc.CalcBaseFee(pool.chainconfig, reset.newHead)</span><br><span class="line">		pool.priced.SetBaseFee(pendingBaseFee)</span><br><span class="line">	&#125;</span><br><span class="line">	// Update all accounts to the latest known pending nonce</span><br><span class="line">	nonces := make(map[common.Address]uint64, len(pool.pending))</span><br><span class="line">	for addr, list := range pool.pending &#123;</span><br><span class="line">		highestPending := list.LastElement()</span><br><span class="line">		nonces[addr] = highestPending.Nonce() + 1</span><br><span class="line">	&#125;</span><br><span class="line">	pool.pendingNonces.setAll(nonces)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们首先分析 <code>demoteUnexecutables</code>  函数，代码如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">func (pool *TxPool) demoteUnexecutables() &#123;</span><br><span class="line">	// 迭代交易池内的 pending 队列</span><br><span class="line">	for addr, list := range pool.pending &#123;</span><br><span class="line">		nonce := pool.currentState.GetNonce(addr)</span><br><span class="line"></span><br><span class="line">		// 删除交易中 nonce 较低的交易</span><br><span class="line">		olds := list.Forward(nonce)</span><br><span class="line">		for _, tx := range olds &#123;</span><br><span class="line">			hash := tx.Hash()</span><br><span class="line">			pool.all.Remove(hash)</span><br><span class="line">			log.Trace(&quot;Removed old pending transaction&quot;, &quot;hash&quot;, hash)</span><br><span class="line">		&#125;</span><br><span class="line">		// 丢弃到所有账户无法支付 gas 费用的交易</span><br><span class="line">		// drops 是所有无法支付 gas 费用的交易</span><br><span class="line">		// invalids 是指低于 drops 中最低 nonce 交易的列表</span><br><span class="line">		drops, invalids := list.Filter(pool.currentState.GetBalance(addr), pool.currentMaxGas)</span><br><span class="line">		for _, tx := range drops &#123;</span><br><span class="line">			hash := tx.Hash()</span><br><span class="line">			log.Trace(&quot;Removed unpayable pending transaction&quot;, &quot;hash&quot;, hash)</span><br><span class="line">			pool.all.Remove(hash)</span><br><span class="line">		&#125;</span><br><span class="line">		pendingNofundsMeter.Mark(int64(len(drops)))</span><br><span class="line">		// invalids 内包含的交易可能符合要求，也有可能不符合要求</span><br><span class="line">		// 所以交易应该进入 queued 队列</span><br><span class="line">		for _, tx := range invalids &#123;</span><br><span class="line">			hash := tx.Hash()</span><br><span class="line">			log.Trace(&quot;Demoting pending transaction&quot;, &quot;hash&quot;, hash)</span><br><span class="line"></span><br><span class="line">			// Internal shuffle shouldn&#x27;t touch the lookup set.</span><br><span class="line">			pool.enqueueTx(hash, tx, false, false)</span><br><span class="line">		&#125;</span><br><span class="line">		// 更新计数器</span><br><span class="line">		pendingGauge.Dec(int64(len(olds) + len(drops) + len(invalids)))</span><br><span class="line">		if pool.locals.contains(addr) &#123;</span><br><span class="line">			localGauge.Dec(int64(len(olds) + len(drops) + len(invalids)))</span><br><span class="line">		&#125;</span><br><span class="line">		// 交易列表长度大于 0 ，但交易列表内没有找到 nonce 为最新 nonce 的交易</span><br><span class="line">		// 这意味着交易列表内的所有交易都是可能过时的</span><br><span class="line">		if list.Len() &gt; 0 &amp;&amp; list.txs.Get(nonce) == nil &#123;</span><br><span class="line">			// 利用 Cap 返回交易列表内所有交易</span><br><span class="line">			// Cap 的功能是限制列表内的交易数，此处限制为 0</span><br><span class="line">			gapped := list.Cap(0)</span><br><span class="line">			// 执行交易降级</span><br><span class="line">			for _, tx := range gapped &#123;</span><br><span class="line">				hash := tx.Hash()</span><br><span class="line">				log.Error(&quot;Demoting invalidated transaction&quot;, &quot;hash&quot;, hash)</span><br><span class="line"></span><br><span class="line">				// Internal shuffle shouldn&#x27;t touch the lookup set.</span><br><span class="line">				pool.enqueueTx(hash, tx, false, false)</span><br><span class="line">			&#125;</span><br><span class="line">			// 重置计数器</span><br><span class="line">			pendingGauge.Dec(int64(len(gapped)))</span><br><span class="line">			blockReorgInvalidatedTx.Mark(int64(len(gapped)))</span><br><span class="line">		&#125;</span><br><span class="line">		// 如果发现 list(账户地址对应的交易列表)为空，则直接在交易池内删除此账户</span><br><span class="line">		if list.Empty() &#123;</span><br><span class="line">			delete(pool.pending, addr)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们通过注释分析了以上代码，此代码的一大特点是在新区块到来时会对 <code>pending</code>  队列中不符合新区块要求的交易进行降级处理。</p>
<p>在完成交易降级流程后，我们使用以下代码进行 <code>nonce</code>  的重置:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nonces := make(map[common.Address]uint64, len(pool.pending))</span><br><span class="line">for addr, list := range pool.pending &#123;</span><br><span class="line">	highestPending := list.LastElement()</span><br><span class="line">	nonces[addr] = highestPending.Nonce() + 1</span><br><span class="line">&#125;</span><br><span class="line">pool.pendingNonces.setAll(nonces)</span><br></pre></td></tr></table></figure>
<p>我们通过 <code>list.LastElement()</code>  获得最新的交易，然后将交易的 <code>nonce + 1</code>  作为我们目前跟踪的 <code>nonce</code> 。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结">#</a> 总结</h2>
<p>本文主要介绍了一个交易从构建到打包进入区块的完整过程，基本分析了以太坊交易池的实现和构成，也设计了部分交易打包和执行的内容。主要内容列表如下:</p>
<ol>
<li>以太坊交易池的基本参数和初始化</li>
<li>交易参数的含义与使用 <code>MetaMask API</code>  构建交易</li>
<li>交易池内交易队列</li>
<li>交易池增加交易使用的函数</li>
<li>交易池内的 <code>scheduleReorgLoop</code>  调度函数及相关 <code>channel</code></li>
<li><code>runReorg</code>  函数实现交易提权的过程</li>
<li>交易打包和执行的基本情况</li>
<li><code>runReorg</code>  在新区块到达情况下重置交易池状态的情况</li>
</ol>
<p>考虑到读者可以希望自己阅读源代码，此处给出关于交易的核心函数流程图，为了简单，此流程图省略了部分数据结构，如下:</p>
<p><img src="https://s-bj-3358-blog.oss.dogecdn.com/svg/txFunction.drawio.svg" alt=""></p>

  </article>
</div>


    
<div class="container disqus-container">
  <div id="disqus_thread"></div>
</div>

<script>
  var disqus_config = function() {
    this.page.url = "https://sai.show/2023/09/17/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%9A%84%E4%BA%A4%E6%98%93%E4%B8%8E%E4%BA%A4%E6%98%93%E6%B1%A0/";
    this.page.identifier = 1694884822;
  };

  (function() {
    var d = document, s = d.createElement('script');
    s.src = 'https://gith-u-b.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
  })();
</script>





</div>

<div class="footer-wrapper container">
  <footer class="footer clearfix">
    <div class="clearfix">
    <a href="https://sai.show" class="footer-logo">
      <i class="fa fa-github"></i>
    </a>
    <ul class="footer-social-link">
      <li>© 2023 Sai</li>
      <li><a href="https://sai.show">Home</a></li>
      
      <li><a target="_blank" rel="noopener" href="https://github.com/gith-u-b">Github</a></li>
      
    </ul>
    <div class="footer-theme-info">
      Author
      by <a target="_blank" rel="noopener" href="//github.com/sabrinaluo">Sai</a> ❤ Powered by Hexo
    </div>
    </div>
    
  </footer>
</div>


<script>
  (function() {
    var cx = 'c1bcc49ff0304472a';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
      '//cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>



<script src="/js/main.js"></script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"superSample":2,"width":250,"height":500,"position":"right","hOffset":0,"vOffset":-20},"mobile":{"show":false,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
